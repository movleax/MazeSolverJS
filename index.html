<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>MazeSolverJS</title>
    <style>
    	* { padding: 0; margin: 0; }
    	canvas { background: #eee; display: block; margin: 0 auto; }
		
		body
		{
			background-color: #4a506b;
		}
    </style>
</head>
<body>

<canvas id="myCanvas" width="512" height="512"></canvas>

<input type="file" id="fileinput" />

<script>
	var canvas = document.getElementById("myCanvas");
	var ctx = canvas.getContext("2d");
	var fileLoaded = false;
	var map;
	var BlockWidth = 16;
	var BlockHeight = 16;
	var blocks = [];
	
	function readSingleFile(evt) 
	{
		//Retrieve the first (and only!) File from the FileList object
		var f = evt.target.files[0]; 
		var result;
		if (f) {
		  var r = new FileReader();
		  r.onload = function(e) { 
			  var contents = e.target.result;
			//console.log(r.result);
			result = r.result;
			map = result;
			fileLoaded = true;
			//console.log(map);
		  }
		  r.readAsText(f);
		  
		} else { 
		  alert("Failed to load file");
		}
		
		checkLoad();
	}
	  
	document.getElementById('fileinput').addEventListener('change', readSingleFile, false);
		
	function checkLoad() 
	{
		if (!fileLoaded) 
		{
			console.log("waiting...");
			setTimeout("checkLoad();", 1000);
			return;
		} 
		else 
		{
			console.log("in...");
			console.log(map);
			ParseMap();
		}
	}

	function ParseMap()
	{
		var x=0;
		var y=0;
	
		for(var i=0; i < map.length; i++)
		{
			if(map[i] == '\r')
			{
				y += BlockHeight;
				x = 0;
				continue;
			}
			else if(map[i] == '\n')
			{
				continue;
			}
			
			if(map[i] == 'X')
			{
				blocks.push(new Block(x, y, BlockWidth, BlockHeight, ctx));
			}
			
			x += BlockWidth;
		}
	}
	
	class CollisionBox
	{
		constructor(x, y, w, h)
		{
			this.x = x;
			this.y = y;
			this.width = w;
			this.height = h;
		}
		
		UpdateCollisionBox(x, y, w, h)
		{
			this.x = x;
			this.y = y;
			this.width = w;
			this.height = h;
		}
	}
	
	class iCollidable
	{
		constructor()
		{

		}

		GetCollisionBox()
		{
			throw "Function not implemented!";
		}
		CheckCollision(otherCollisionBox)
		{
			throw "Function not implemented!";
		}
		CollisionAction()
		{
			throw "Function not implemented!";
		}
	}
	
	class Block extends iCollidable
	{
		constructor(x, y, width, height, ctx)
		{
			super();
			this.ctx = ctx;
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
			this.cBox = new CollisionBox(x, y, width, height);
		}
		
		Draw()
		{
			ctx.beginPath();
			ctx.rect(this.x, this.y, this.width, this.height);
			ctx.fillStyle = "#c0c7d3";
			ctx.fill();
			ctx.closePath();
		}
		
		GetCollisionBox()
		{
			return this.cBox;
		}
		
		CheckCollision(otherCollisionBox)
		{
			if( (this.cBox.x >= otherCollisionBox.x && this.cBox.x <= otherCollisionBox.x + otherCollisionBox.w) && (this.cBox.y >= otherCollisionBox.y && this.cBox.y <= otherCollisionBox.y + otherCollisionBox.h) )
			{
				return true;
			}
			
			return false;
		}
	}
	
	class Character extends Block
	{
		constructor(x, y, width, height, ctx)
		{
			super(x, y, width, height, ctx);
		}
		
		Draw()
		{
			ctx.beginPath();
			ctx.rect(this.x, this.y, this.width, this.height);
			ctx.fillStyle = "red";
			ctx.fill();
			ctx.closePath();
		}
	}
	
	class End extends Block
	{
		constructor(x, y, width, height, ctx)
		{
			super(x, y, width, height, ctx);
		}
		
		Draw()
		{
			ctx.beginPath();
			ctx.rect(this.x, this.y, this.width, this.height);
			ctx.fillStyle = "blue";
			ctx.fill();
			ctx.closePath();
		}
	}
	
	
	function Draw() 
	{
		
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		
		// draw background
		ctx.fillStyle = '#162802';
		ctx.fillRect(0,0,canvas.width, canvas.height);
		
		
		for(var it in blocks)
		{
			blocks[it].Draw();
		}
	}
	
	setInterval(Draw, 10);
	
</script>

</body>
</html>